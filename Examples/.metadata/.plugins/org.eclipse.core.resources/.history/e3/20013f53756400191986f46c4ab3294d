#include "user.h"
#include "lcd.h"
#include "../Components/cs43l22/cs43l22.h"
#include "stm32f411e_discovery_audio.h"

#define ONESEC 1000

uint8_t spiData[3];
uint8_t r;
uint32_t tickCtr;
uint32_t prevTick;
uint16_t cData[5];
uint8_t cBtns[5][16];
uint8_t txBuff[50];

uint32_t adc[2], adcDMA[2];

uint16_t vol, bpm, volOld, bpmOld;

uint8_t t;
uint8_t tm;
float tempF;
uint16_t timer;

FIL Files[5];
#define AUDIO_BUFFER_SIZE 4096
uint32_t sampleRate = 0;
uint8_t Volume = 70;
uint32_t fSize[5]; //Max filesize of the given row
FIL FileCall[80]; //File array to use for playing
uint32_t bLeft[80]; //Number of bytes remaining to read for the given file pointer
__IO BUFFER_StateTypeDef BufferOffset = BUFFER_OFFSET_NONE;
uint8_t AudioBuffer[AUDIO_BUFFER_SIZE];

static uint8_t USBH_USR_ApplicationState = USBH_USR_FS_INIT;

void userInit() {
	r = 0;
	tickCtr = 0;
	prevTick = HAL_GetTick();

	cData[0] = 0b0000000000000000;
	cData[1] = 0b0000000000000000;
	cData[2] = 0b0000000000000000;
	cData[3] = 0b0000000000000000;
	cData[4] = 0b0000000000000000;

	initBtns();
	startLEDs();

	initLCD();

	//HAL_UART_Transmit_DMA(&huart1, txBuff, 17);

	HAL_ADC_Start_DMA(&hadc1, adcDMA, 2);

}

void userLoop() {

	switch (Appli_state) {
	case APPLICATION_READY:
		//THINGS
		switch (USBH_USR_ApplicationState) {
		case USBH_USR_FS_INIT:
			f_mount(&USBHFatFS, (TCHAR const*) USBHPath, 0);
			USBH_USR_ApplicationState = USBH_USR_AUDIO;
			break;
		case USBH_USR_AUDIO:
			//WavePlayerStart();
			USBH_USR_ApplicationState = USBH_USR_FS_INIT;
			break;
		}
		break;
	case APPLICATION_IDLE:
	default:
		break;
	}

	//Do nothing between ticks
	while (HAL_GetTick() == prevTick)
		;
	tickCtr++;
	prevTick = HAL_GetTick();

	updateLCD();

	//if(tickCtr % 1 == 0){
	sendLED();
	r++;
	if (r >= 5) {
		r = 0;
	}
	//}

	//Resets on high (PE11) /\ Clk on PE12
	if (tickCtr % (ONESEC / 160) == 0) {
		incrBtns();
	}

	timer = (4096 - adc[0]) * ONESEC / 4095;
	if (tickCtr >= timer) {
		t++;
		if (t == 16) {
			t = 0;
		}
		incrCol(t);

		//sprintf(txBuff, "A: %04u B: %04u\r\n", adc[0], adc[1]);
		//HAL_UART_Transmit_DMA(&huart1, txBuff, 17);

		bpmOld = bpm;
		volOld = vol;

		bpm = 60 * 4095 / (4096 - adc[0]);
		vol = adc[1] * 100 / 4095;

		if (bpm != bpmOld || vol != volOld) {
			lcdRefresh(vol, bpm);
		}

		//once a second tick counter resets
		tickCtr = 0;
	}

}

void sendLED() {
	//Get Data
	spiData[1] = ((cData[r] & 0xFF00) >> 8);
	spiData[0] = (cData[r] & 0x00FF);
	spiData[2] = (0b10000000 >> r);

	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET); //Enable Goes Low
	HAL_SPI_Transmit(&hspi5, spiData, 3, 10); //Transmit 3 bytes
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET); //Enable Goes High
}

void setLED(uint8_t row, uint8_t col, uint8_t val) {
	/*
	 * row - value from 0 to 4
	 * col - value from 0 to 15
	 * val - 1 or 0 to set bit
	 */
	cData[row] = (cData[row] & ~(1 << (15 - col))) | (val << (15 - col));
}

void toggleLED(uint8_t row, uint8_t col) {
	/*
	 * row - value from 0 to 4
	 * col - value from 0 to 15
	 */
	cData[row] ^= 1 << (15 - col);
}

void toggleLEDCol(uint8_t col) {
	uint8_t i;
	for (i = 0; i < 5; i++) {
		toggleLED(i, col);
	}
}

void incrCol(uint8_t col) {
	uint8_t cl = col - 1;
	if (col == 0) {
		cl = 15;
	}
	toggleLEDCol(col);
	toggleLEDCol(cl);
}

void startLEDs() {
	t = 0;
	toggleLEDCol(0);
}

void stopLEDs() {
	toggleLEDCol(t);
}

void initBtns() {
	HAL_GPIO_WritePin(GPIOE, GPIO_PIN_11, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GPIOE, GPIO_PIN_12, GPIO_PIN_RESET);
	tm = 0;
	resetBtns();
}

void incrBtns() {
	tm++;
	if (tm == 16) {
		tm = 0;
	}
	HAL_GPIO_WritePin(GPIOE, GPIO_PIN_12, GPIO_PIN_SET);
	HAL_GPIO_WritePin(GPIOE, GPIO_PIN_12, GPIO_PIN_RESET);

	GPIO_TypeDef* letter[] = { GPIOE, GPIOE, GPIOE, GPIOE, GPIOC };
	uint16_t number[] = { GPIO_PIN_7, GPIO_PIN_8, GPIO_PIN_9, GPIO_PIN_10,
	GPIO_PIN_4 };
	uint8_t i;

	for (i = 0; i < 5; i++) {
		if (cBtns[i][tm] != HAL_GPIO_ReadPin(letter[i], number[i])) {
			//Change
			if (cBtns[i][tm] == 0) {
				//Update the LED
				//setLED(0, tm, ~cBtns[0][tm]);
				toggleLED(i, tm);
			}
			//Change the value of the array
			cBtns[i][tm] = ~cBtns[i][tm];
		}
	}
}

void resetBtns() {
	HAL_GPIO_WritePin(GPIOE, GPIO_PIN_11, GPIO_PIN_SET);
	HAL_GPIO_WritePin(GPIOE, GPIO_PIN_11, GPIO_PIN_RESET);
}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
	adc[0] = adcDMA[0];
	adc[1] = adcDMA[1];
}

void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart) {
}

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
}

/**
 * Returns 0 for no errors, 1 for file not found, 2 for non-matching sample rate, 3 for cannot open filter
 */
uint8_t initFiles() {
	char path[] = "0:/";
	char wvName[] = "0:wave0.wav";
	DIR Directory;
	WAVE_FormatTypeDef waveformat;
	UINT bytesread = 0;
	uint8_t outputResult = 0;
	uint32_t fSample[5];

	//Clear the Audio Array
	memset(AudioBuffer, 0, AUDIO_BUFFER_SIZE);

	//Get read out protection status
	if (f_opendir(&Directory, path) == FR_OK) {
		//Open wave file to play

		for (int i = 0; i < 5; i++) {
			if (f_open(&Files[i], wvName, FA_READ) == FR_OK) {
				//Read the header of the file
				f_read(&Files[i], &waveformat, sizeof(waveformat), &bytesread);

				//Get Filesize and samplerate
				fSize[i] = waveformat.FileSize;
				fSample[i] = waveformat.SampleRate;

				if (fSample[0] != fSample[i]) {
					outputResult = 2;
				}
				//reset pointer to home position for reading.
				f_lseek(&Files[i], 0);

			} else {
				//Error! File not found
				outputResult = 1;
				return outputResult;
			}
			wvName[6]++;
		}

		sampleRate = fSample[0];
		//Initialize the audio handler (DMA, I2S, I2C)
		BSP_AUDIO_OUT_Init(OUTPUT_DEVICE_AUTO, Volume, sampleRate);
		BSP_AUDIO_OUT_Play((uint16_t*) &AudioBuffer[0], AUDIO_BUFFER_SIZE);

	} else {
		outputResult = 3;
	}
	return outputResult;
}

/**
 * The function where the file will be copied from the prototype into the buffer and the bytes left will be reset
 */
void primeCol(uint8_t col) {
	uint8_t datapt = 0;
	for (int i = 0; i < 5; i++) {
		datapt = col * i;
		//If the LED is on in this position, cue sound, otherwise set bLeft to 0
		if(((cData[i]) & (1 << col)) >> col == 1){
			bLeft[datapt] = fSize[i];
			FileCall[datapt] = Files[i];
		}else{
			bLeft[datapt] = 0;
		}
	}
}

void fillDMAArr() {
	uint16_t halfSz = AUDIO_BUFFER_SIZE / 2;
	uint16_t dataPart[halfSz];
	uint8_t singleDataPc[halfSz];
	uint8_t divisor = 0;
	uint32_t bytesread;
	uint16_t offs = 0;

	if (BufferOffset != BUFFER_OFFSET_NONE) {
		switch (BufferOffset) {
		case BUFFER_OFFSET_FULL:
			offs = halfSz;
			break;
		case BUFFER_OFFSET_HALF:
			offs = 0;
			break;
		case BUFFER_OFFSET_NONE:
			//This is never called, just here for warning suppression
			return;
			break;
		}

		memset(dataPart, 0, halfSz);

		for (int i = 0; i < 80; i++) {
			if (bLeft[i] < halfSz) {
				bLeft[i] = 0;
			}

			if (bLeft[i] != 0) {
				divisor++;
				f_read(&FileCall[i], &singleDataPc[0], halfSz, (void *)&bytesread);
				bLeft[i] -= halfSz;

				for (int j = 0; j < halfSz; j++) {
					dataPart[j] += singleDataPc[j];
				}
			}
		}

		if (divisor == 0) {
			// Fill with zeroes
			for (int j = 0; j < halfSz; j++) {
				AudioBuffer[j + offs] = 0;
			}
		} else {
			for (int j = 0; j < halfSz; j++) {
				AudioBuffer[j + offs] = dataPart[j] / divisor;
			}

		}
		BufferOffset = BUFFER_OFFSET_NONE;
	}
}

/**
  * @brief  Manages the DMA full Transfer complete event.
  */
void BSP_AUDIO_OUT_TransferComplete_CallBack(void)
{
	BufferOffset = BUFFER_OFFSET_FULL;
	BSP_AUDIO_OUT_ChangeBuffer((uint16_t *)&AudioBuffer[0], AUDIO_BUFFER_SIZE / 2);
}

/**
  * @brief  Manages the DMA Half Transfer complete event.
  */
void BSP_AUDIO_OUT_HalfTransfer_CallBack(void)
{
	BufferOffset = BUFFER_OFFSET_HALF;
}
